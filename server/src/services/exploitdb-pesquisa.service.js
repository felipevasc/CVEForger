const axios = require('axios');
const cheerio = require('cheerio');

class ExploitDBPesquisaServico {
  constructor() {
    this.urlBase = 'https://www.exploit-db.com';
    this.urlPesquisa = 'https://www.exploit-db.com/search';
    this.timeout = 30000;
  }

  async buscarExploitsDB(numeroCVE) {
    try {
      console.log(`Buscando exploits no ExploitDB para CVE: ${numeroCVE}`);

      const resultadosPesquisa = await this.pesquisarExploits(numeroCVE);
      const exploitsDetalhados = await this.obterDetalhesExploits(
        resultadosPesquisa
      );

      return this.classificarExploits(exploitsDetalhados);
    } catch (erro) {
      console.error(`Erro ao buscar no ExploitDB: ${erro.message}`);
      return [];
    }
  }

  async pesquisarExploits(numeroCVE) {
    try {
      const parametrosPesquisa = {
        cve: numeroCVE,
        type: '',
        platform: '',
        port: '',
        term: '',
        author: '',
      };

      const resposta = await axios.get(this.urlPesquisa, {
        params: parametrosPesquisa,
        timeout: this.timeout,
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        },
      });

      return this.extrairResultadosPesquisa(resposta.data);
    } catch (erro) {
      console.warn(`Erro na pesquisa inicial: ${erro.message}`);
      return await this.pesquisaAlternativa(numeroCVE);
    }
  }

  async pesquisaAlternativa(numeroCVE) {
    try {
      const numeroLimpo = numeroCVE.replace('CVE-', '');
      const termosPesquisa = [numeroCVE, numeroLimpo];

      const resultados = [];

      for (const termo of termosPesquisa) {
        const resposta = await axios.get(this.urlPesquisa, {
          params: { term: termo },
          timeout: this.timeout,
          headers: {
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          },
        });

        const resultadosTermo = this.extrairResultadosPesquisa(resposta.data);
        resultados.push(...resultadosTermo);
      }

      return this.removerDuplicatas(resultados);
    } catch (erro) {
      console.warn(`Erro na pesquisa alternativa: ${erro.message}`);
      return [];
    }
  }

  extrairResultadosPesquisa(htmlResposta) {
    try {
      const $ = cheerio.load(htmlResposta);
      const resultados = [];

      $('tbody tr').each((indice, elemento) => {
        const $linha = $(elemento);
        const colunas = $linha.find('td');

        if (colunas.length >= 4) {
          const linkExploit = $linha.find('a[href*="/exploits/"]').first();

          if (linkExploit.length > 0) {
            const resultado = {
              id: this.extrairIdExploit(linkExploit.attr('href')),
              titulo: linkExploit.text().trim(),
              url: this.urlBase + linkExploit.attr('href'),
              data: $(colunas[3]).text().trim(),
              autor: $(colunas[4]).text().trim(),
              tipo: $(colunas[5]).text().trim(),
              plataforma: $(colunas[6]).text().trim(),
            };

            resultados.push(resultado);
          }
        }
      });

      return resultados;
    } catch (erro) {
      console.warn(`Erro ao extrair resultados: ${erro.message}`);
      return [];
    }
  }

  extrairIdExploit(urlExploit) {
    const match = urlExploit.match(/\/exploits\/(\d+)/);
    return match ? match[1] : null;
  }

  async obterDetalhesExploits(exploitsBasicos) {
    const exploitsDetalhados = [];

    for (const exploit of exploitsBasicos.slice(0, 10)) {
      try {
        const detalhes = await this.obterDetalhesExploit(exploit);
        exploitsDetalhados.push(detalhes);

        await this.aguardarRequisicao();
      } catch (erro) {
        console.warn(
          `Erro ao obter detalhes do exploit ${exploit.id}: ${erro.message}`
        );
        exploitsDetalhados.push({
          ...exploit,
          erro: erro.message,
        });
      }
    }

    return exploitsDetalhados;
  }

  async obterDetalhesExploit(exploitBasico) {
    try {
      const resposta = await axios.get(exploitBasico.url, {
        timeout: this.timeout,
        headers: {
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        },
      });

      const detalhes = this.extrairDetalhesHTML(resposta.data);
      const codigoExploit = await this.obterCodigoExploit(exploitBasico.id);

      return {
        ...exploitBasico,
        detalhes: detalhes,
        codigo: codigoExploit,
        relevancia: this.calcularRelevanciaExploit(exploitBasico, detalhes),
      };
    } catch (erro) {
      throw new Error(`Falha ao obter detalhes: ${erro.message}`);
    }
  }

  extrairDetalhesHTML(htmlDetalhes) {
    try {
      const $ = cheerio.load(htmlDetalhes);

      const detalhes = {
        descricao: $('meta[name="description"]').attr('content') || '',
        tags: [],
        vulnerabilidades: [],
        referencias: [],
      };

      $('.card-header').each((indice, elemento) => {
        const $header = $(elemento);
        if ($header.text().includes('Vulnerability')) {
          const $conteudo = $header.next('.card-body');
          detalhes.vulnerabilidades.push($conteudo.text().trim());
        }
      });

      $('a[href*="cve.mitre.org"]').each((indice, elemento) => {
        const href = $(elemento).attr('href');
        if (href && !detalhes.referencias.includes(href)) {
          detalhes.referencias.push(href);
        }
      });

      $('.badge').each((indice, elemento) => {
        const tag = $(elemento).text().trim();
        if (tag && !detalhes.tags.includes(tag)) {
          detalhes.tags.push(tag);
        }
      });

      return detalhes;
    } catch (erro) {
      return { erro: erro.message };
    }
  }

  async obterCodigoExploit(idExploit) {
    try {
      const urlCodigo = `${this.urlBase}/exploits/${idExploit}`;
      const urlRaw = `${this.urlBase}/raw/${idExploit}`;

      try {
        const resposta = await axios.get(urlRaw, {
          timeout: this.timeout,
          headers: {
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          },
        });

        return {
          fonte: 'raw',
          codigo: resposta.data,
          tamanho: resposta.data.length,
          linguagem: this.detectarLinguagem(resposta.data),
        };
      } catch (erro) {
        const resposta = await axios.get(urlCodigo, {
          timeout: this.timeout,
          headers: {
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          },
        });

        const $ = cheerio.load(resposta.data);
        const codigoHTML = $('pre code').text() || $('pre').text();

        return {
          fonte: 'html',
          codigo: codigoHTML,
          tamanho: codigoHTML.length,
          linguagem: this.detectarLinguagem(codigoHTML),
        };
      }
    } catch (erro) {
      return {
        erro: erro.message,
        disponivel: false,
      };
    }
  }

  detectarLinguagem(codigo) {
    const indicadores = {
      python: ['#!/usr/bin/python', 'import ', 'def ', 'if __name__'],
      bash: ['#!/bin/bash', '#!/bin/sh', 'echo ', 'chmod '],
      perl: ['#!/usr/bin/perl', 'use ', 'my $'],
      ruby: ['#!/usr/bin/ruby', 'require ', 'def '],
      c: ['#include <', 'int main(', 'printf('],
      php: ['<?php', '<?=', '$_GET', '$_POST'],
      javascript: ['function(', 'var ', 'console.log'],
      powershell: ['PowerShell', 'Get-', 'Set-', '$env:'],
    };

    const codigoLower = codigo.toLowerCase();

    for (const [linguagem, patterns] of Object.entries(indicadores)) {
      const encontrado = patterns.some((pattern) =>
        codigoLower.includes(pattern.toLowerCase())
      );

      if (encontrado) {
        return linguagem;
      }
    }

    return 'desconhecida';
  }

  calcularRelevanciaExploit(exploit, detalhes) {
    let pontuacao = 0;

    if (exploit.data) {
      const dataExploit = new Date(exploit.data);
      const diasDesdePublicacao =
        (Date.now() - dataExploit.getTime()) / (1000 * 60 * 60 * 24);
      pontuacao += Math.max(0, 100 - diasDesdePublicacao / 10);
    }

    if (detalhes.tags) {
      pontuacao += detalhes.tags.length * 2;
    }

    if (detalhes.vulnerabilidades) {
      pontuacao += detalhes.vulnerabilidades.length * 5;
    }

    const tiposPreferidos = ['remote', 'local', 'dos', 'code execution'];
    if (exploit.tipo) {
      const tipoLower = exploit.tipo.toLowerCase();
      const temTipoPreferido = tiposPreferidos.some((tipo) =>
        tipoLower.includes(tipo)
      );

      if (temTipoPreferido) pontuacao += 10;
    }

    return pontuacao;
  }

  classificarExploits(exploits) {
    return exploits
      .sort((a, b) => (b.relevancia || 0) - (a.relevancia || 0))
      .map((exploit, indice) => ({
        posicao: indice + 1,
        id: exploit.id,
        titulo: exploit.titulo,
        url: exploit.url,
        autor: exploit.autor,
        data: exploit.data,
        tipo: exploit.tipo,
        plataforma: exploit.plataforma,
        relevancia: exploit.relevancia,
        detalhes: exploit.detalhes,
        codigo: exploit.codigo,
      }));
  }

  removerDuplicatas(exploits) {
    const exploitsUnicos = new Map();

    exploits.forEach((exploit) => {
      if (!exploitsUnicos.has(exploit.id)) {
        exploitsUnicos.set(exploit.id, exploit);
      }
    });

    return Array.from(exploitsUnicos.values());
  }

  async aguardarRequisicao() {
    return new Promise((resolve) => setTimeout(resolve, 2000));
  }
}

module.exports = new ExploitDBPesquisaServico();
