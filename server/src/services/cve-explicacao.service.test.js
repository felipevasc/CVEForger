const CVEExplicacaoServico = require('./cve-explicacao.service'); // Assuming class instance export
const cveInformacaoServico = require('./cve-informacao.service');
const githubPesquisaServico = require('./github-pesquisa.service');
const exploitDBPesquisaServico = require('./exploitdb-pesquisa.service');
const llmServico = require('./llm.service');
const promptsExplicacaoModelo = require('../prompts/prompts-explicacao.model');
const fs = require('fs').promises;
const path = require('path');

// Mock dependencies
jest.mock('./cve-informacao.service');
jest.mock('./github-pesquisa.service');
jest.mock('./exploitdb-pesquisa.service');
jest.mock('./llm.service');
jest.mock('../prompts/prompts-explicacao.model');
jest.mock('fs', () => ({
    ...jest.requireActual('fs'),
    promises: {
        mkdir: jest.fn(),
        writeFile: jest.fn(),
        readFile: jest.fn(), // For obterHTMLSalvo
    }
}));

describe('CVEExplicacaoServico', () => {
  const numeroCVE = 'CVE-2023-8888';
  let cveExplicacaoServicoInstance;

  beforeEach(() => {
    cveInformacaoServico.obterInformacoesCVE.mockReset();
    githubPesquisaServico.buscarPOCsNoGithub.mockReset();
    exploitDBPesquisaServico.buscarExploitsDB.mockReset();
    llmServico.processarPrompt.mockReset();
    promptsExplicacaoModelo.obterPromptExplicacaoInicial.mockReset();
    promptsExplicacaoModelo.obterPromptRefinamentoExplicacao.mockReset();
    promptsExplicacaoModelo.obterPromptValidacaoFinal.mockReset();
    promptsExplicacaoModelo.obterPromptEnriquecimentoTecnico.mockReset();
    fs.mkdir.mockReset();
    fs.writeFile.mockReset();
    fs.readFile.mockReset();
    
    cveExplicacaoServicoInstance = CVEExplicacaoServico;
  });

  describe('gerarExplicacaoCompleta', () => {
    it('should orchestrate explanation generation and save HTML file', async () => {
      const mockDadosColetados = {
        informacoesCVE: { id: numeroCVE, fontes: ['NVD'] },
        pocsGithub: [{ nomeCompleto: 'poc1', urlAPI: 'url1', linguagem: 'Python', codigoPrincipal: 'code1' }],
        exploitsDB: [{ id: 'edb1', codigo: 'code-edb' }],
        estatisticas: { totalFontes: 2, fontesComCodigo: 2, linguagensPrincipais: ['Python'] }
      };
      const mockInitialHTML = '<p>Initial explanation</p>';
      const mockValidatedHTML = '<!DOCTYPE html><html><body>Validated and refined explanation</body></html>';

      // Mock internal methods for simplicity in this top-level test
      jest.spyOn(cveExplicacaoServicoInstance, 'coletarDadosCompletos').mockResolvedValue(mockDadosColetados);
      jest.spyOn(cveExplicacaoServicoInstance, 'gerarHTMLExplicativo').mockResolvedValue(mockInitialHTML);
      jest.spyOn(cveExplicacaoServicoInstance, 'validarEAprimorarHTML').mockResolvedValue(mockValidatedHTML);
      // salvarHTMLGerado is called directly, so we check fs.writeFile

      const result = await cveExplicacaoServicoInstance.gerarExplicacaoCompleta(numeroCVE);

      expect(cveExplicacaoServicoInstance.coletarDadosCompletos).toHaveBeenCalledWith(numeroCVE);
      expect(cveExplicacaoServicoInstance.gerarHTMLExplicativo).toHaveBeenCalledWith(numeroCVE, mockDadosColetados);
      expect(cveExplicacaoServicoInstance.validarEAprimorarHTML).toHaveBeenCalledWith(numeroCVE, mockInitialHTML, mockDadosColetados);
      
      const expectedDir = path.join(__dirname, '../../output/explicacoes', numeroCVE);
      expect(fs.mkdir).toHaveBeenCalledWith(expectedDir, { recursive: true });
      
      const expectedHTMLPath = path.join(expectedDir, `explicacao-${numeroCVE.toLowerCase()}.html`);
      expect(fs.writeFile).toHaveBeenCalledWith(expectedHTMLPath, mockValidatedHTML, 'utf8');
      
      const expectedMetadataPath = path.join(expectedDir, 'metadados.json');
      expect(fs.writeFile).toHaveBeenCalledWith(expectedMetadataPath, expect.any(String)); // Check for metadata file

      expect(result).toEqual(expect.objectContaining({
        numeroCVE: numeroCVE,
        htmlGerado: mockValidatedHTML,
        statusProcessamento: 'concluido',
      }));
      
      jest.restoreAllMocks();
    });
    
    it('should throw an error if data collection fails', async () => {
        jest.spyOn(cveExplicacaoServicoInstance, 'coletarDadosCompletos').mockRejectedValue(new Error('Failed to collect data'));
        
        await expect(cveExplicacaoServicoInstance.gerarExplicacaoCompleta(numeroCVE))
            .rejects.toThrow('Falha na geração de explicação: Failed to collect data');
        
        jest.restoreAllMocks();
    });
  });

  describe('coletarDadosCompletos', () => {
    it('should gather data from all sources and enrich it', async () => {
        const mockInfo = { id: numeroCVE, description: 'Test CVE' };
        const mockPocs = [{ nomeCompleto: 'user/repo', urlAPI: 'api_url', linguagem: 'Python' }];
        const mockExploits = [{ id: '123', codigo: 'exploit code' }];
        
        cveInformacaoServico.obterInformacoesCVE.mockResolvedValue(mockInfo);
        githubPesquisaServico.buscarPOCsNoGithub.mockResolvedValue(mockPocs);
        exploitDBPesquisaServico.buscarExploitsDB.mockResolvedValue(mockExploits);
        
        // Mock enrichment steps
        githubPesquisaServico.obterConteudoDetalhado.mockResolvedValue({
            arquivosRelevantes: ['README.md'],
            codigoPrincipal: 'print("hello")',
            documentacao: 'Some docs'
        });
        // Mock internal call to this.analisarCodigoExploit
        const analisarSpy = jest.spyOn(cveExplicacaoServicoInstance, 'analisarCodigoExploit').mockResolvedValue({
            linguagemDetectada: 'Python',
            funcoesPrincipais: ['main']
        });

        const result = await cveExplicacaoServicoInstance.coletarDadosCompletos(numeroCVE);

        expect(cveInformacaoServico.obterInformacoesCVE).toHaveBeenCalledWith(numeroCVE);
        expect(githubPesquisaServico.buscarPOCsNoGithub).toHaveBeenCalledWith(numeroCVE);
        expect(exploitDBPesquisaServico.buscarExploitsDB).toHaveBeenCalledWith(numeroCVE);
        expect(githubPesquisaServico.obterConteudoDetalhado).toHaveBeenCalledWith('api_url');
        expect(analisarSpy).toHaveBeenCalledWith('exploit code');
        
        expect(result.informacoesCVE).toEqual(mockInfo);
        expect(result.pocsGithub[0].codigoPrincipal).toBe('print("hello")');
        expect(result.exploitsDB[0].analiseDetalhada.linguagemDetectada).toBe('Python');
        expect(result.estatisticas.fontesComCodigo).toBe(2); // Both had code
        
        jest.restoreAllMocks();
    });
  });
  
  // TODO: Add more granular tests for:
  // - enriquecerDadosPOCs
  // - analisarCodigoExploit and its sub-methods (detectarLinguagem, etc.)
  // - gerarHTMLExplicativo (including refinement loop)
  // - validarEAprimorarHTML (including enrichment logic)
  // - avaliarQualidadeHTML
  // - salvarHTMLGerado (error handling)
  // - obterHTMLSalvo
});
