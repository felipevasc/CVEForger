const axios = require('axios');
const { parse } = require('csv-parse');
const { platform } = require('os');
const fs = require('fs').promises;
const path = require('path');

const EXPLOIT_DB_CSV_URL =
  'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv';

// caminhos dos arquivos locais
const CSV_LOCAL_PATH = path.resolve(__dirname, 'exploitdb.csv');
const META_PATH = path.resolve(__dirname, 'exploitdb_meta.json');

/**
 * Recupera o conteúdo do CSV, buscando remoto no máximo uma vez por dia.
 * @returns {Promise<string>} Conteúdo CSV
 */
async function obterConteudoCSV() {
  const hoje = new Date().toISOString().slice(0, 10); // 'YYYY-MM-DD'
  let fazerDownload = true;

  try {
    const metaRaw = await fs.readFile(META_PATH, 'utf8');
    const meta = JSON.parse(metaRaw);
    if (meta.lastFetch === hoje) {
      fazerDownload = false;
    }
  } catch {
    // se não existir o arquivo de meta, continua com download = true
  }

  if (fazerDownload) {
    console.log(`Buscando CSV remoto (${hoje})...`);
    const resposta = await axios.get(EXPLOIT_DB_CSV_URL, {
      responseType: 'text',
    });
    const conteudo = resposta.data;
    // salva CSV local
    await fs.writeFile(CSV_LOCAL_PATH, conteudo, 'utf8');
    // atualiza metadata
    await fs.writeFile(
      META_PATH,
      JSON.stringify({ lastFetch: hoje }, null, 2),
      'utf8'
    );
    console.log('CSV salvo localmente e metadata atualizada.');
    return conteudo;
  } else {
    console.log('Lendo CSV do cache local...');
    return fs.readFile(CSV_LOCAL_PATH, 'utf8');
  }
}

/**
 * Extrai identificadores CVE de uma string de códigos.
 * Exemplo: "CVE-2021-1234;MSF-123;OSVDB-456"
 * @param {string} codigosStr
 * @returns {string[]}
 */
function extrairCVEs(codigosStr) {
  if (!codigosStr || typeof codigosStr !== 'string') return [];
  const cveRegex = /CVE-\d{4}-\d{4,7}/gi;
  const matches = codigosStr.match(cveRegex);
  return matches
    ? Array.from(new Set(matches.map((cve) => cve.toUpperCase())))
    : [];
}

/**
 * Obtém e processa o CSV (local ou remoto) para extrair CVEs únicos.
 * @returns {Promise<{cve: string, description: string}[]>}
 */
async function obterCVEsDoExploitDB() {
  try {
    const conteudoCsv = await obterConteudoCSV();
    console.log('Processando CSV...');
    return new Promise((resolve, reject) => {
      const cvesUnicos = new Set();
      const parser = parse(conteudoCsv, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
      });

      parser.on('readable', () => {
        let registro;
        while ((registro = parser.read()) !== null) {
          if (registro.codes) {
            extrairCVEs(registro.codes).forEach((cve) =>
              cvesUnicos.add({
                cve,
                description: registro.description,
                platform: registro.platform,
              })
            );
          }
        }
      });

      parser.on('error', (erro) => {
        console.error('Erro no parser CSV:', erro);
        reject(new Error('Falha ao processar dados do Exploit-DB.'));
      });

      parser.on('end', () => {
        const lista = Array.from(cvesUnicos).sort();
        console.log(`Encontrados ${lista.length} CVEs únicos.`);
        resolve(lista);
      });
    });
  } catch (err) {
    console.error('Erro ao obter CVEs do Exploit-DB:', err.message);
    throw err;
  }
}

module.exports = {
  obterCVEsDoExploitDB,
};
