const cveInformacaoServico = require('./cve-informacao.service');
const githubPesquisaServico = require('./github-pesquisa.service');
const exploitDBPesquisaServico = require('./exploitdb-pesquisa.service');
const llmServico = require('./llm.service');
const promptsModelo = require('../prompts/prompts.model');
const fs = require('fs').promises;
const path = require('path');

class CVEAnaliseServico {
  async analisarCVECompleta(numeroCVE) {
    try {
      console.log(`Iniciando análise completa da CVE: ${numeroCVE}`);

      const informacoesCVE = await this.coletarInformacoesCVE(numeroCVE);
      const planoPOC = await this.gerarPlanoPOC(numeroCVE, informacoesCVE);
      const dockerCompose = await this.gerarDockerCompose(
        numeroCVE,
        informacoesCVE,
        planoPOC
      );

      await this.salvarArquivosGerados(numeroCVE, {
        informacoes: informacoesCVE,
        plano: planoPOC,
        dockerCompose: dockerCompose,
      });

      return {
        informacoesCVE: informacoesCVE,
        planoPOC: planoPOC,
        dockerCompose: dockerCompose,
        statusProcessamento: 'concluido',
      };
    } catch (erro) {
      console.error(`Erro na análise da CVE ${numeroCVE}:`, erro);
      throw new Error(`Falha na análise da CVE: ${erro.message}`);
    }
  }

  async coletarInformacoesCVE(numeroCVE) {
    console.log(`Coletando informações da CVE: ${numeroCVE}`);

    const informacoesCVE = await cveInformacaoServico.obterInformacoesCVE(
      numeroCVE
    );
    const pocsGithub = await githubPesquisaServico.buscarPOCsNoGithub(
      numeroCVE
    );
    const exploitsDB = await exploitDBPesquisaServico.buscarExploitsDB(
      numeroCVE
    );

    return {
      dadosBasicos: informacoesCVE,
      pocsGithub: pocsGithub,
      exploitsDB: exploitsDB,
      totalFontesEncontradas: pocsGithub.length + exploitsDB.length,
    };
  }

  async gerarPlanoPOC(numeroCVE, informacoesCVE) {
    console.log(`Gerando plano de POC para CVE: ${numeroCVE}`);

    const promptInicial = promptsModelo.obterPromptAnalisePOC(
      numeroCVE,
      informacoesCVE
    );
    let respostaLLM = await llmServico.processarPrompt(promptInicial);

    let tentativasRefinamento = 0;
    const maxTentativas = 3;

    while (tentativasRefinamento < maxTentativas) {
      const avaliacaoResposta = await this.avaliarQualidadeResposta(
        respostaLLM,
        informacoesCVE
      );

      if (avaliacaoResposta.suficiente) {
        break;
      }

      const promptRefinamento = promptsModelo.obterPromptRefinamento(
        respostaLLM,
        avaliacaoResposta.pontosFracos
      );

      respostaLLM = await llmServico.processarPrompt(promptRefinamento);
      tentativasRefinamento++;
    }

    return respostaLLM;
  }

  async gerarDockerCompose(numeroCVE, informacoesCVE, planoPOC) {
    console.log(`Gerando docker-compose para CVE: ${numeroCVE}`);

    const promptDockerCompose = promptsModelo.obterPromptDockerCompose(
      numeroCVE,
      informacoesCVE,
      planoPOC
    );

    let dockerCompose = await llmServico.processarPrompt(promptDockerCompose);

    let tentativasValidacao = 0;
    const maxTentativas = 2;

    while (tentativasValidacao < maxTentativas) {
      const validacao = await this.validarDockerCompose(dockerCompose);

      if (validacao.valido) {
        break;
      }

      const promptCorrecao = promptsModelo.obterPromptCorrecaoDockerCompose(
        dockerCompose,
        validacao.erros
      );

      dockerCompose = await llmServico.processarPrompt(promptCorrecao);
      tentativasValidacao++;
    }

    return dockerCompose;
  }

  async avaliarQualidadeResposta(resposta, informacoesCVE) {
    const criterios = [
      'componentes necessários',
      'ambiente de ataque',
      'ambiente alvo',
      'passos de exploração',
      'ferramentas específicas',
    ];

    const pontosFracos = [];

    for (const criterio of criterios) {
      if (!resposta.toLowerCase().includes(criterio.toLowerCase())) {
        pontosFracos.push(`Falta detalhamento sobre: ${criterio}`);
      }
    }

    const suficiente = pontosFracos.length <= 1 && resposta.length > 500;

    return {
      suficiente: suficiente,
      pontosFracos: pontosFracos,
      tamanhoResposta: resposta.length,
    };
  }

  async validarDockerCompose(dockerCompose) {
    const erros = [];

    if (!dockerCompose.includes('version:')) {
      erros.push('Falta especificação de versão do docker-compose');
    }

    if (!dockerCompose.includes('services:')) {
      erros.push('Falta definição de serviços');
    }

    if (
      !dockerCompose.includes('networks:') &&
      dockerCompose.includes('network_mode:')
    ) {
      erros.push('Configuração de rede inconsistente');
    }

    return {
      valido: erros.length === 0,
      erros: erros,
    };
  }

  async salvarArquivosGerados(numeroCVE, dados) {
    const diretorioSaida = path.join(__dirname, '../../output', numeroCVE);

    try {
      await fs.mkdir(diretorioSaida, { recursive: true });

      await fs.writeFile(
        path.join(diretorioSaida, 'informacoes.json'),
        JSON.stringify(dados.informacoes, null, 2)
      );

      await fs.writeFile(
        path.join(diretorioSaida, 'plano-poc.txt'),
        dados.plano
      );

      await fs.writeFile(
        path.join(diretorioSaida, 'docker-compose.yml'),
        dados.dockerCompose
      );

      console.log(`Arquivos salvos em: ${diretorioSaida}`);
    } catch (erro) {
      console.warn(`Erro ao salvar arquivos: ${erro.message}`);
    }
  }
}

module.exports = new CVEAnaliseServico();
