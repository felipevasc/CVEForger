const cveInformacaoServico = require('./cve-informacao.service');
const githubPesquisaServico = require('./github-pesquisa.service');
const exploitDBPesquisaServico = require('./exploitdb-pesquisa.service');
const llmServico = require('./llm.service');
const promptsExplicacaoModelo = require('../prompts/prompts-explicacao.model');
const fs = require('fs').promises;
const path = require('path');

class CVEExplicacaoServico {
  async gerarExplicacaoCompleta(numeroCVE) {
    try {
      console.log(`Iniciando geração de explicação para CVE: ${numeroCVE}`);

      const dadosCompletos = await this.coletarDadosCompletos(numeroCVE);
      const htmlExplicativo = await this.gerarHTMLExplicativo(
        numeroCVE,
        dadosCompletos
      );
      const htmlValidado = await this.validarEAprimorarHTML(
        numeroCVE,
        htmlExplicativo,
        dadosCompletos
      );

      await this.salvarHTMLGerado(numeroCVE, htmlValidado);

      return {
        numeroCVE: numeroCVE,
        htmlGerado: htmlValidado,
        dadosUtilizados: {
          fontesInformacoes: dadosCompletos.informacoesCVE.fontes,
          totalPOCsGithub: dadosCompletos.pocsGithub.length,
          totalExploitsDB: dadosCompletos.exploitsDB.length,
        },
        statusProcessamento: 'concluido',
        timestampGeracao: new Date().toISOString(),
      };
    } catch (erro) {
      console.error(`Erro na geração de explicação da CVE ${numeroCVE}:`, erro);
      throw new Error(`Falha na geração de explicação: ${erro.message}`);
    }
  }

  async coletarDadosCompletos(numeroCVE) {
    console.log(`Coletando dados completos para CVE: ${numeroCVE}`);

    const informacoesCVE = await cveInformacaoServico.obterInformacoesCVE(
      numeroCVE
    );
    const pocsGithub = await githubPesquisaServico.buscarPOCsNoGithub(
      numeroCVE
    );
    const exploitsDB = await exploitDBPesquisaServico.buscarExploitsDB(
      numeroCVE
    );

    const dadosEnriquecidos = await this.enriquecerDadosPOCs(
      pocsGithub,
      exploitsDB
    );

    return {
      informacoesCVE: informacoesCVE,
      pocsGithub: dadosEnriquecidos.pocsEnriquecidas,
      exploitsDB: dadosEnriquecidos.exploitsEnriquecidos,
      estatisticas: {
        totalFontes: pocsGithub.length + exploitsDB.length,
        fontesComCodigo: dadosEnriquecidos.fontesComCodigo,
        linguagensPrincipais: dadosEnriquecidos.linguagensPrincipais,
      },
    };
  }

  async enriquecerDadosPOCs(pocsGithub, exploitsDB) {
    const pocsEnriquecidas = [];
    const exploitsEnriquecidos = [];
    let fontesComCodigo = 0;
    const linguagens = {};

    for (const poc of pocsGithub) {
      try {
        if (poc.urlAPI) {
          const conteudoDetalhado =
            await githubPesquisaServico.obterConteudoDetalhado(poc.urlAPI);
          poc.arquivosRelevantes = conteudoDetalhado.arquivosRelevantes;
          poc.codigoPrincipal = conteudoDetalhado.codigoPrincipal;
          poc.documentacao = conteudoDetalhado.documentacao;

          if (poc.codigoPrincipal) {
            fontesComCodigo++;
          }

          if (poc.linguagem) {
            linguagens[poc.linguagem] = (linguagens[poc.linguagem] || 0) + 1;
          }
        }
        pocsEnriquecidas.push(poc);
      } catch (erro) {
        console.warn(
          `Erro ao enriquecer POC ${poc.nomeCompleto}:`,
          erro.message
        );
        pocsEnriquecidas.push(poc);
      }
    }

    for (const exploit of exploitsDB) {
      try {
        if (exploit.codigo) {
          const analiseExploit = await this.analisarCodigoExploit(
            exploit.codigo
          );
          exploit.analiseDetalhada = analiseExploit;
          fontesComCodigo++;
        }
        exploitsEnriquecidos.push(exploit);
      } catch (erro) {
        console.warn(`Erro ao enriquecer exploit ${exploit.id}:`, erro.message);
        exploitsEnriquecidos.push(exploit);
      }
    }

    return {
      pocsEnriquecidas,
      exploitsEnriquecidos,
      fontesComCodigo,
      linguagensPrincipais: Object.keys(linguagens)
        .sort((a, b) => linguagens[b] - linguagens[a])
        .slice(0, 3),
    };
  }

  async analisarCodigoExploit(codigo) {
    const linhas = codigo.split('\n');
    const analise = {
      totalLinhas: linhas.length,
      linguagemDetectada: this.detectarLinguagem(codigo),
      funcoesPrincipais: this.extrairFuncoesPrincipais(codigo),
      bibliotecasUsadas: this.extrairBibliotecasUsadas(codigo),
      variaveisChave: this.extrairVariaveisChave(codigo),
      comentariosRelevantes: this.extrairComentariosRelevantes(codigo),
    };

    return analise;
  }

  detectarLinguagem(codigo) {
    if (
      codigo.includes('#!/usr/bin/python') ||
      codigo.includes('import ') ||
      codigo.includes('def ')
    )
      return 'Python';
    if (codigo.includes('#!/bin/bash') || codigo.includes('#!/bin/sh'))
      return 'Bash';
    if (codigo.includes('#include') || codigo.includes('int main'))
      return 'C/C++';
    if (codigo.includes('<?php')) return 'PHP';
    if (codigo.includes('function ') && codigo.includes('var '))
      return 'JavaScript';
    if (codigo.includes('public class') || codigo.includes('import java.'))
      return 'Java';
    return 'Desconhecida';
  }

  extrairFuncoesPrincipais(codigo) {
    const funcoes = [];
    const padroesFuncoes = [
      /def\s+(\w+)\s*\(/g,
      /function\s+(\w+)\s*\(/g,
      /(\w+)\s*\(\)\s*{/g,
    ];

    padroesFuncoes.forEach((padrao) => {
      let match;
      while ((match = padrao.exec(codigo)) !== null) {
        funcoes.push(match[1]);
      }
    });

    return funcoes.slice(0, 5);
  }

  extrairBibliotecasUsadas(codigo) {
    const bibliotecas = [];
    const padroesImport = [
      /import\s+(\w+)/g,
      /from\s+(\w+)\s+import/g,
      /#include\s+[<"](\w+)[">]/g,
      /require\(['"](\w+)['"]\)/g,
    ];

    padroesImport.forEach((padrao) => {
      let match;
      while ((match = padrao.exec(codigo)) !== null) {
        bibliotecas.push(match[1]);
      }
    });

    return [...new Set(bibliotecas)].slice(0, 10);
  }

  extrairVariaveisChave(codigo) {
    const variaveis = [];
    const padroes = [
      /(\w*(?:url|host|port|target|payload|exploit)\w*)\s*=/gi,
      /(\w*(?:vuln|attack|cmd|shell)\w*)\s*=/gi,
    ];

    padroes.forEach((padrao) => {
      let match;
      while ((match = padrao.exec(codigo)) !== null) {
        variaveis.push(match[1]);
      }
    });

    return [...new Set(variaveis)].slice(0, 5);
  }

  extrairComentariosRelevantes(codigo) {
    const comentarios = [];
    const linhas = codigo.split('\n');

    linhas.forEach((linha) => {
      const comentario = linha.match(/(?:#|\/\/|\/\*)\s*(.+?)(?:\*\/)?$/);
      if (comentario && comentario[1].length > 10) {
        comentarios.push(comentario[1].trim());
      }
    });

    return comentarios.slice(0, 3);
  }

  async gerarHTMLExplicativo(numeroCVE, dadosCompletos) {
    console.log(`Gerando HTML explicativo para CVE: ${numeroCVE}`);

    const promptInicial = promptsExplicacaoModelo.obterPromptExplicacaoInicial(
      numeroCVE,
      dadosCompletos.informacoesCVE,
      dadosCompletos.pocsGithub,
      dadosCompletos.exploitsDB
    );

    let htmlGerado = await llmServico.processarPrompt(promptInicial, {
      maxTokens: 8000,
      temperatura: 0.2,
    });

    let tentativasRefinamento = 0;
    const maxTentativas = 3;

    while (tentativasRefinamento < maxTentativas) {
      const avaliacaoHTML = await this.avaliarQualidadeHTML(
        htmlGerado,
        numeroCVE
      );

      if (avaliacaoHTML.adequado) {
        break;
      }

      console.log(
        `Refinando HTML (tentativa ${
          tentativasRefinamento + 1
        }/${maxTentativas})`
      );

      const promptRefinamento =
        promptsExplicacaoModelo.obterPromptRefinamentoExplicacao(
          htmlGerado,
          avaliacaoHTML.pontosFracos
        );

      htmlGerado = await llmServico.processarPrompt(promptRefinamento, {
        maxTokens: 8000,
        temperatura: 0.1,
      });

      tentativasRefinamento++;
    }

    return htmlGerado;
  }

  async validarEAprimorarHTML(numeroCVE, htmlGerado, dadosCompletos) {
    console.log(`Validando e aprimorando HTML para CVE: ${numeroCVE}`);

    const promptValidacao = promptsExplicacaoModelo.obterPromptValidacaoFinal(
      htmlGerado,
      numeroCVE
    );
    const resultadoValidacao = await llmServico.processarPrompt(
      promptValidacao,
      {
        maxTokens: 1000,
        temperatura: 0.1,
      }
    );

    if (resultadoValidacao.includes('VALIDO: NAO')) {
      console.log('HTML necessita aprimoramento baseado na validação');

      const informacoesAdicionais =
        this.extrairInformacoesAdicionais(dadosCompletos);
      const promptEnriquecimento =
        promptsExplicacaoModelo.obterPromptEnriquecimentoTecnico(
          htmlGerado,
          informacoesAdicionais
        );

      return await llmServico.processarPrompt(promptEnriquecimento, {
        maxTokens: 8000,
        temperatura: 0.1,
      });
    }

    return htmlGerado;
  }

  extrairInformacoesAdicionais(dadosCompletos) {
    const informacoes = [];

    if (dadosCompletos.estatisticas.linguagensPrincipais.length > 0) {
      informacoes.push(
        `Linguagens principais usadas nas POCs: ${dadosCompletos.estatisticas.linguagensPrincipais.join(
          ', '
        )}`
      );
    }

    dadosCompletos.pocsGithub.forEach((poc) => {
      if (poc.codigoPrincipal) {
        informacoes.push(
          `Trecho de código relevante do ${
            poc.nomeCompleto
          }: ${poc.codigoPrincipal.substring(0, 500)}`
        );
      }
    });

    dadosCompletos.exploitsDB.forEach((exploit) => {
      if (exploit.analiseDetalhada) {
        informacoes.push(
          `Análise do exploit ${exploit.id}: Linguagem ${
            exploit.analiseDetalhada.linguagemDetectada
          }, Funções: ${exploit.analiseDetalhada.funcoesPrincipais.join(', ')}`
        );
      }
    });

    return informacoes.join('\n\n');
  }

  async avaliarQualidadeHTML(html, numeroCVE) {
    const criteriosObrigatorios = [
      'alto nível',
      'médio nível',
      'baixo nível',
      'riscos',
      'mitigação',
      '<style>',
      '<script>',
      'interativ',
    ];

    const pontosFracos = [];

    criteriosObrigatorios.forEach((criterio) => {
      if (!html.toLowerCase().includes(criterio.toLowerCase())) {
        pontosFracos.push(`Ausência de: ${criterio}`);
      }
    });

    if (!html.includes('<!DOCTYPE html>')) {
      pontosFracos.push('Estrutura HTML incompleta');
    }

    if (html.length < 5000) {
      pontosFracos.push('Conteúdo muito superficial');
    }

    if (!html.includes(numeroCVE)) {
      pontosFracos.push('CVE não referenciada adequadamente');
    }

    return {
      adequado: pontosFracos.length <= 1,
      pontosFracos: pontosFracos,
      tamanhoHTML: html.length,
    };
  }

  async salvarHTMLGerado(numeroCVE, html) {
    const diretorioSaida = path.join(
      __dirname,
      '../../output/explicacoes',
      numeroCVE
    );

    try {
      await fs.mkdir(diretorioSaida, { recursive: true });

      const nomeArquivo = `explicacao-${numeroCVE.toLowerCase()}.html`;
      const caminhoCompleto = path.join(diretorioSaida, nomeArquivo);

      await fs.writeFile(caminhoCompleto, html, 'utf8');

      const metadados = {
        numeroCVE: numeroCVE,
        dataGeracao: new Date().toISOString(),
        tamanhoHTML: html.length,
        nomeArquivo: nomeArquivo,
        caminhoCompleto: caminhoCompleto,
      };

      await fs.writeFile(
        path.join(diretorioSaida, 'metadados.json'),
        JSON.stringify(metadados, null, 2)
      );

      console.log(`HTML explicativo salvo em: ${caminhoCompleto}`);

      return {
        caminhoArquivo: caminhoCompleto,
        nomeArquivo: nomeArquivo,
        metadados: metadados,
      };
    } catch (erro) {
      console.warn(`Erro ao salvar HTML: ${erro.message}`);
      throw erro;
    }
  }

  async obterHTMLSalvo(numeroCVE) {
    const diretorioSaida = path.join(
      __dirname,
      '../../output/explicacoes',
      numeroCVE
    );
    const nomeArquivo = `explicacao-${numeroCVE.toLowerCase()}.html`;
    const caminhoCompleto = path.join(diretorioSaida, nomeArquivo);

    try {
      const html = await fs.readFile(caminhoCompleto, 'utf8');
      const metadados = await fs.readFile(
        path.join(diretorioSaida, 'metadados.json'),
        'utf8'
      );

      return {
        html: html,
        metadados: JSON.parse(metadados),
        encontrado: true,
      };
    } catch (erro) {
      return {
        html: null,
        metadados: null,
        encontrado: false,
      };
    }
  }
}

module.exports = new CVEExplicacaoServico();
