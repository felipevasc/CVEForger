const CVEAnaliseServico = require('./cve-analise.service'); // Assuming the class is exported as default or CVEAnaliseServico
const cveInformacaoServico = require('./cve-informacao.service');
const githubPesquisaServico = require('./github-pesquisa.service');
const exploitDBPesquisaServico = require('./exploitdb-pesquisa.service');
const llmServico = require('./llm.service');
const promptsModelo = require('../prompts/prompts.model');
const fs = require('fs').promises;
const path = require('path');

// Mock dependencies
jest.mock('./cve-informacao.service');
jest.mock('./github-pesquisa.service');
jest.mock('./exploitdb-pesquisa.service');
jest.mock('./llm.service');
jest.mock('../prompts/prompts.model');
jest.mock('fs', () => ({ // Mock fs.promises for writeFile and mkdir
    ...jest.requireActual('fs'),
    promises: {
        mkdir: jest.fn(),
        writeFile: jest.fn(),
    }
}));

describe('CVEAnaliseServico', () => {
  const numeroCVE = 'CVE-2023-9999';
  let cveAnaliseServicoInstance;

  beforeEach(() => {
    // Reset mocks for each test
    cveInformacaoServico.obterInformacoesCVE.mockReset();
    githubPesquisaServico.buscarPOCsNoGithub.mockReset();
    exploitDBPesquisaServico.buscarExploitsDB.mockReset();
    llmServico.processarPrompt.mockReset();
    promptsModelo.obterPromptAnalisePOC.mockReset();
    promptsModelo.obterPromptDockerCompose.mockReset();
    promptsModelo.obterPromptRefinamento.mockReset();
    promptsModelo.obterPromptCorrecaoDockerCompose.mockReset();
    fs.mkdir.mockReset();
    fs.writeFile.mockReset();
    
    // Create a new instance for each test if the service has state,
    // or use the exported singleton if it's stateless.
    // The provided service is a class instance, so we use it directly.
    cveAnaliseServicoInstance = CVEAnaliseServico; 
  });

  describe('analisarCVECompleta', () => {
    it('should orchestrate CVE analysis and save files', async () => {
      // Mock data returned by dependent services
      const mockInfo = { dadosBasicos: { id: numeroCVE }, pocsGithub: [], exploitsDB: [] };
      const mockPlanoPOC = 'Generated POC plan.';
      const mockDockerCompose = 'Generated docker-compose.yml';

      cveInformacaoServico.obterInformacoesCVE.mockResolvedValue(mockInfo.dadosBasicos);
      githubPesquisaServico.buscarPOCsNoGithub.mockResolvedValue(mockInfo.pocsGithub);
      exploitDBPesquisaServico.buscarExploitsDB.mockResolvedValue(mockInfo.exploitsDB);
      
      // Mock LLM responses
      // First call for initial POC plan
      llmServico.processarPrompt.mockResolvedValueOnce(mockPlanoPOC); 
      // Second call for initial Docker Compose
      llmServico.processarPrompt.mockResolvedValueOnce(mockDockerCompose);

      // Mock prompt generations
      promptsModelo.obterPromptAnalisePOC.mockReturnValue('prompt for poc');
      promptsModelo.obterPromptDockerCompose.mockReturnValue('prompt for docker');

      // Mock evaluation and validation to be successful on first try
      // This requires spying on the service's own methods or making them mockable
      jest.spyOn(cveAnaliseServicoInstance, 'avaliarQualidadeResposta').mockResolvedValue({ suficiente: true });
      jest.spyOn(cveAnaliseServicoInstance, 'validarDockerCompose').mockResolvedValue({ valido: true });
      
      const result = await cveAnaliseServicoInstance.analisarCVECompleta(numeroCVE);

      expect(cveInformacaoServico.obterInformacoesCVE).toHaveBeenCalledWith(numeroCVE);
      expect(llmServico.processarPrompt).toHaveBeenCalledTimes(2); // poc + docker-compose
      expect(promptsModelo.obterPromptAnalisePOC).toHaveBeenCalled();
      expect(promptsModelo.obterPromptDockerCompose).toHaveBeenCalled();
      
      expect(fs.mkdir).toHaveBeenCalledWith(expect.stringContaining(path.join('output', numeroCVE)), { recursive: true });
      expect(fs.writeFile).toHaveBeenCalledTimes(3); // informacoes.json, plano-poc.txt, docker-compose.yml
      expect(fs.writeFile).toHaveBeenCalledWith(expect.stringContaining(path.join(numeroCVE, 'informacoes.json')), expect.any(String));
      expect(fs.writeFile).toHaveBeenCalledWith(expect.stringContaining(path.join(numeroCVE, 'plano-poc.txt')), mockPlanoPOC);
      expect(fs.writeFile).toHaveBeenCalledWith(expect.stringContaining(path.join(numeroCVE, 'docker-compose.yml')), mockDockerCompose);

      expect(result).toEqual({
        informacoesCVE: expect.objectContaining({ dadosBasicos: mockInfo.dadosBasicos }),
        planoPOC: mockPlanoPOC,
        dockerCompose: mockDockerCompose,
        statusProcessamento: 'concluido',
      });
      
      // Restore spies
      jest.restoreAllMocks();
    });

    it('should attempt refinement if POC plan quality is insufficient', async () => {
        const mockInfo = { dadosBasicos: { id: numeroCVE }, pocsGithub: [], exploitsDB: [] };
        const initialPlanoPOC = 'Initial weak POC plan.';
        const refinedPlanoPOC = 'Refined POC plan.';
        const mockDockerCompose = 'Generated docker-compose.yml';

        cveInformacaoServico.obterInformacoesCVE.mockResolvedValue(mockInfo.dadosBasicos);
        githubPesquisaServico.buscarPOCsNoGithub.mockResolvedValue([]);
        exploitDBPesquisaServico.buscarExploitsDB.mockResolvedValue([]);

        llmServico.processarPrompt
            .mockResolvedValueOnce(initialPlanoPOC)  // Initial POC
            .mockResolvedValueOnce(refinedPlanoPOC)    // Refined POC
            .mockResolvedValueOnce(mockDockerCompose); // Docker Compose

        promptsModelo.obterPromptAnalisePOC.mockReturnValue('prompt for poc');
        promptsModelo.obterPromptRefinamento.mockReturnValue('prompt for refinement');
        promptsModelo.obterPromptDockerCompose.mockReturnValue('prompt for docker');
        
        // Spy and mock evaluateQualidadeResposta
        const evaluateSpy = jest.spyOn(cveAnaliseServicoInstance, 'avaliarQualidadeResposta')
            .mockResolvedValueOnce({ suficiente: false, pontosFracos: ['detail missing'] }) // Fails first time
            .mockResolvedValueOnce({ suficiente: true }); // Succeeds second time
        
        jest.spyOn(cveAnaliseServicoInstance, 'validarDockerCompose').mockResolvedValue({ valido: true });


        await cveAnaliseServicoInstance.analisarCVECompleta(numeroCVE);

        expect(llmServico.processarPrompt).toHaveBeenCalledTimes(3); // initial poc, refined poc, docker
        expect(evaluateSpy).toHaveBeenCalledTimes(2);
        expect(promptsModelo.obterPromptRefinamento).toHaveBeenCalledWith(initialPlanoPOC, ['detail missing']);
        expect(fs.writeFile).toHaveBeenCalledWith(expect.stringContaining('plano-poc.txt'), refinedPlanoPOC);
        
        jest.restoreAllMocks();
    });
    
    it('should throw an error if a critical step fails', async () => {
        cveInformacaoServico.obterInformacoesCVE.mockRejectedValue(new Error('Failed to fetch info'));
        
        await expect(cveAnaliseServicoInstance.analisarCVECompleta(numeroCVE)).rejects.toThrow('Falha na an√°lise da CVE: Failed to fetch info');
    });
  });

  // TODO: Add more granular tests for:
  // - coletarInformacoesCVE
  // - gerarPlanoPOC (including refinement loop logic)
  // - gerarDockerCompose (including validation loop logic)
  // - avaliarQualidadeResposta
  // - validarDockerCompose
  // - salvarArquivosGerados (error handling during file save)
});
